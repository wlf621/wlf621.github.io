---
title: 模拟
date: 2020-08-08 16:22:10
mathjax: true
tags:
- 模拟
---

## [验证给定的字符串是否可以解释为十进制数字](https://leetcode-cn.com/problems/valid-number/)

> "0" => true
" 0.1 " => true
"abc" => false
"1 a" => false
"2e10" => true
" -90e3   " => true
" 1e" => false
"e3" => false
" 6e-1" => true
" 99e2.5 " => false
"53.5e93" => true
" --6 " => false
"-+3" => false
"95a54e53" => false

<details><summary>查看代码</summary><pre><code>
class Solution {
public:
    bool isNumber(string s) {//模拟： '.', 'e'只能出现一次，'+','-'只能出现在数字前面或'e'后面且最多出现两次，'e'后面要出现数字不能出现'.'；其他情况不是数字
        //去掉首尾空格
        s.erase(0, s.find_first_not_of(" "));
        s.erase(s.find_last_not_of(" ") + 1);

        bool isNumber = false, dotFlag = false, plusFlag = false, eFlag = false, minusFlag = false;
        for (int i = 0; i < s.size(); i++) {
            if ('0' <= s[i] && s[i] <= '9') {
                isNumber = true;
            }
            else if ((s[i] == '+' && !plusFlag && !isNumber && !dotFlag) || (s[i] == '+' && !plusFlag && !isNumber && eFlag)) {/*'+'只能出现在数字前面或
                'e'后面且最多出现两次， !dotFlag防止".+"这种情况*/
                plusFlag = true;
                isNumber = false;
            }
            else if ((s[i] == '-' && !minusFlag && !isNumber && !dotFlag) || (s[i] == '-' && !minusFlag && !isNumber && eFlag)) {/*'-'只能出现在数字前面或
                'e'后面且最多出现两次， !dotFlag防止".-"这种情况*/
                minusFlag = true;
                isNumber = false;
            }
            else if (s[i] == 'e' && !eFlag && isNumber) {/* 'e'只能出现一次且前后必须出现数字，出现'e'和可以再次出现'+','-'*/
                eFlag = true;
                isNumber = false;
                minusFlag = false;
                plusFlag = false;
            }
            else if (s[i] == '.' && !dotFlag && !eFlag) {/* '.'只能出现一次且不能出现再'e'后面*/
                dotFlag = true;
            }
            else return false;
        }
        return isNumber;
    }
};
</code></pre></details>

## LRU缓存机制

> 要求get(key),put(key)是O(1)时间复杂度
Hash表加双向链表，头表示最近使用的，尾表示最近未使用的；

<details><summary>查看代码</summary><pre><code>
struct DLinkedNode{
    int key, val;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode(int k = 0, int v = 0) :key(k), val(v), prev(nullptr), next(nullptr) {}
};

class LRUCache {
private:
    unordered_map<int, DLinkedNode*> Cache;
    DLinkedNode* head;
    DLinkedNode* tail;
    int size;
    int capacity;
public:
    LRUCache(int _capacity = 0); 
    int get(int key);
    void put(int key, int value);
    void moveTohead(DLinkedNode* node);
    void addTohead(DLinkedNode* node);
    void removeNode(DLinkedNode* node);
    DLinkedNode* removeTail();
};

int main() {
    //int a;
    //cin >> a;
    LRUCache cache(2);
    cache.put(1, 1);
    cache.put(2, 2);
    cout << cache.get(1) << endl;
    cout << cache.get(2) << endl;
    cache.put(3, 3);
    cout << cache.get(1) << endl;
    return 0;
}

LRUCache::LRUCache(int _capacity) : capacity(_capacity), size(0) {
    // 使用伪头部和伪尾部节点
    head = new DLinkedNode();
    tail = new DLinkedNode();
    head->next = tail;
    tail->prev = head;
}
int LRUCache::get(int key)
{
    if (!Cache.count(key)) {
        return -1;
    }
    // 如果 key 存在，先通过哈希表定位，再移到头部
    DLinkedNode* node = Cache[key];
    this->moveTohead(node);
    return node->val;
}

void LRUCache::put(int key, int value)
{
    if (!Cache.count(key)) {
        // 如果 key 不存在，创建一个新的节点
        DLinkedNode* node = new DLinkedNode(key, value);
        // 添加进哈希表
        Cache[key] = node;
        // 添加至双向链表的头部
        this->addTohead(node);
        ++size;
        if (size > capacity) {
            // 如果超出容量，删除双向链表的尾部节点
            DLinkedNode* removed = removeTail();
            // 删除哈希表中对应的项
            Cache.erase(removed->key);
            // 防止内存泄漏
            delete removed;
            --size;
        }
    }
    else {
        // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
        DLinkedNode* node = Cache[key];
        node->val = value;
        this->moveTohead(node);
    }
}

void LRUCache::moveTohead(DLinkedNode* node)
{
    addTohead(node);
    removeNode(node);
}

void LRUCache::addTohead(DLinkedNode* node)
{
    head->next->prev = node;
    node->next = head->next;
    head->next = node;
    node->prev = head;
}

void LRUCache::removeNode(DLinkedNode* node)
{
    node->prev->next = node->next;
    node->next->prev = node->prev;
}

DLinkedNode* LRUCache::removeTail()
{
    DLinkedNode* node = tail->prev;
    removeNode(node);
    return node;
}
</code></pre></details>

## [扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)

如果一个地雷（'M'）被挖出，游戏就结束了- 把它改为 'X'。
如果一个没有相邻地雷的空方块（'E'）被挖出，修改它为（'B'），并且所有和其相邻的未挖出方块都应该被递归地揭露。
如果一个至少与一个地雷相邻的空方块（'E'）被挖出，修改它为数字（'1'到'8'），表示相邻地雷的数量。
如果在此次点击中，若无更多方块可被揭露，则返回面板。

> 输入: 
[['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'M', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E']]
Click : [3,0]
输出: 
[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

<details><summary>查看代码</summary><pre><code>
class Solution {
private:
    int dir[8][2] = { { -1,0 }, {-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1} };

public:
    int getNum(vector<vector<char>>& board, vector<int>& click) {
        int ans = 0, _i, _j;
        for (int i = 0; i < 8; i++) {
            _i = click[0] + dir[i][0]; _j = click[1] + dir[i][1];
            if (_i >= 0 && _i < board.size() && _j >= 0 && _j < board[0].size() && board[_i][_j] == 'M')ans++;
        }
        return ans;
    }
    void helper(vector<vector<char>>& board, vector<int>& click, vector<vector<int>> &visited) {
        if (board[click[0]][click[1]] == 'M'&&!visited[click[0]][click[1]]) {
            visited[click[0]][click[1]] = 1;
            board[click[0]][click[1]] = 'X';
            return;
        }
        else if (board[click[0]][click[1]] == 'E'&&!visited[click[0]][click[1]]) {
            int temp = getNum(board, click);
            if (temp != 0) {
                visited[click[0]][click[1]] = 1;
                board[click[0]][click[1]] = temp + '0';
                return;
            }
            else {
                visited[click[0]][click[1]] = 1;
                board[click[0]][click[1]] =  'B';
                for (int i = 0; i < 8; i++) {
                    int _i = click[0], _j = click[1];
                    click[0] = click[0] + dir[i][0], click[1] = click[1] + dir[i][1];
                    if (click[0] >= 0 && click[0] < board.size() && click[1] >= 0 && click[1] < board[0].size())
                        helper(board, click, visited);
                    click[1]=_j;
                    click[0]=_i;
                }
                return;
            }
        }
        return;
    }
    vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {
        if (board.size() == 0 || board[0].size() == 0)return board;
        vector<vector<int>> visited(board.size(), vector<int>(board[0].size(), 0));
        helper(board, click, visited);
        return board;
    }
};
</code></pre></details>

## [把字符串转换成整数](https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)
写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。

>输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。

<details><summary>查看代码</summary><pre><code>
class Solution {
public:
    int strToInt(string str) {
        if (str.size() == 0)return 0;
        long long ans = 0, flag = 1;
        str.erase(0,str.find_first_not_of(' '));
        if(str.find_first_of(' ') != string::npos) str.erase(str.find_first_of(' '));
        int i = 0;
        if (str[0] == '-') {
            flag = -1;
            i++;
        }
        for (; i < str.size(); i++) {
            if(str[i]=='+'&&i==0)continue;//'+'在第一位跳过
            if (str[i] <= '9' && str[i] >= '0')
                ans = ans * 10 + str[i] - '0';
            else break;//遇到非数字则跳出
            if(ans>INT_MAX)return flag==1?INT_MAX: INT_MIN;//超过int的范围
        }
        return flag*ans;
    }
};
</code></pre></details>

## 约瑟夫环

<details><summary>查看代码</summary><pre><code>
class Node {
public:
    int val;
    Node* next;

    Node(int _val) {
        val = _val;
        next = NULL;
    }
};

class Solution {
public:
    int lastRemaining(int n, int m) {
        int ans;
        Node* l = new Node(0), * p, * pre;
        p = l;
        for (int i = 0; i < n; i++) {
            Node* t = new Node(i);
            p->next = t;
            p = p->next;
        }
        l = l->next;
        p->next = l;
        pre = p;
        p = l;
        while (n > 1) {
            for (int i = 1; i < m; i++) {
                pre = p;
                p = p->next;
            }
            pre->next = p->next;
            delete p;
            p = pre->next;
            n--;
        }
        return p->val;
    }
};
</code></pre></details>

## [n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)
把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

>输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]

<details><summary>查看代码</summary><pre><code>
//掷掷骰子的出现点数的概率
class Solution {
private:
    map<int, double> t;
    map<int, double> s;
    vector<double> ans;
public:
    vector<double> twoSum(int n) {
        for (int i = 1; i < 7; i++) s[i] = 1.0 / 6;
        n--;
        while (n--) {
            t.clear();
            for (int i = 1; i < 7; i++) {
                for (auto it = s.begin(); it != s.end(); it++) {
                    if (t.count(it->first + i) == 0) {
                        t[it->first + i] = it->second * 1.0 / 6;
                    }else{
                        t[it->first + i] = it->second * 1.0 / 6 + t[it->first + i];
                    }
                }
            }
            s.clear();
            for (auto it = t.begin(); it != t.end(); it++)s[it->first] = it->second;
        }
        for (auto it = s.begin(); it != s.end(); it++)ans.push_back(it->second);
        return ans;
    }
};
</code></pre></details>

## [队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)
请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

>输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]

<details><summary>查看代码</summary><pre><code>
//利用双端队列保存最大值
class MaxQueue {
private:
    queue<int> s;
    deque<int> t;
public:
    MaxQueue() {

    }
    
    int max_value() {
        if (!t.empty())return t.back();
        else return -1;
    }
    
    void push_back(int value) {
        while (!t.empty() && value > t.front())t.pop_front();
        s.push(value);
        t.push_front(value);
    }
    int pop_front() {
        if (!s.empty()) {
            if (s.front() == t.back())t.pop_back();
            int t = s.front();
            s.pop();
            return t;
        }
        else return -1;
    }
};
</code></pre></details>

## 大数乘法

<details><summary>查看代码</summary><pre><code>
vector<int> bigNumberMultiply2(vector<int> num1, vector<int> num2) {
    // 分配一个空间，用来存储运算的结果，num1长的数 * num2长的数，结果不会超过num1+num2长
    vector<int> result(num1.size() + num2.size());

    // 先不考虑进位问题，根据竖式的乘法运算，num1的第i位与num2的第j位相乘，结果应该存放在结果的第i+j位上
    for (int i = 0; i < num1.size(); i++) {
        for (int j = 0; j < num2.size(); j++) {
            result[i + j +1] += num1[i] * num2[j];	 // (因为进位的问题，最终放置到第i+j+1位)
        }
    }
    
    //单独处理进位
    for (int k = result.size() - 1; k > 0; k--) {
        if (result[k] >= 10) {
            result[k - 1] += result[k] / 10;
            result[k] %= 10;
        }
    }
    return result;
}
</code></pre></details>