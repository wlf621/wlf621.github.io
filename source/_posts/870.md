---
title: '1652'
date: 2022-10-8 20:30:22
categories:
- leetcode
mathjax: true
tag:
- 贪心

---

给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums2 的优势可以用满足 nums1[i] > nums2[i] 的索引 i 的数目来描述。

返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。

### 示例 1：
```
输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]
输出：[2,11,7,15]
```
### 示例 2：
```
输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11]
输出：[24,32,8,12]
```

<details><summary>查看代码</summary><pre><code>
/*
*  代码可以优化，用数组维护idx，减少存储和循环次数
*/
bool _cmp(pair<int, int>& a, pair<int, int>& b) {
    return a.first < b.first;
}

class Solution {
public:
    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {
        int len = nums1.size();
        vector<int> ans(len, -1);
        vector<pair<int, int>> nums1Map(len);
        vector<pair<int, int>> nums2Map(len);
        for (int i = 0; i < len; i++) {
            nums1Map[i] = make_pair(nums1[i], -1);
            nums2Map[i] = make_pair(nums2[i], i);
        }
        sort(nums1Map.begin(), nums1Map.end(), _cmp);
        sort(nums2Map.begin(), nums2Map.end(), _cmp);

        int i1 = 0, i2 = 0;
        while (i1 < len && i2 < len) {
            if (nums1Map[i1].first > nums2Map[i2].first) {
                nums1Map[i1].second = nums2Map[i2].second;
                i1++;
                i2++;
            }
            else i1++;
        }
        for (int i = 0; i < len; i++) {
            if (nums1Map[i].second != -1) {
                ans[nums1Map[i].second] = nums1Map[i].first;
            }
        }
    
        i1 = 0;
        for (int i = 0; i < len; i++) {
            if (ans[i] != -1) {
                continue;
            }
            while (nums1Map[i1].second != -1) {
                i1++;
            }
            ans[i] = nums1Map[i1++].first;
        }
        
        return ans;
    }
};
</code></pre></details>

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/advantage-shuffle