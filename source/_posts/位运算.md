---
title: 位运算
date: 2020-07-27 09:54:49
categories:
- 位运算
mathjax: true
---

## [数字范围按位与](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/)
给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。

>输入: [5,7]
输出: 4

<details><summary>查看代码</summary><pre><code>
class Solution {//暴力加剪枝侥幸AC
public:
    int rangeBitwiseAnd(int m, int n) {
        int tmp = m;
        for (long long i = m; i <= n; i++) {
            tmp = tmp & i;
            if (tmp == 0)break;
        }
        return tmp;
    }
};

//Brian Kernighan 算法
//范围与实际求二进制公共前缀，number 和 number−1 之间进行按位与运算后，number 中最右边的 11 会被抹去变成 00，直到m<=n即为公共前缀。

class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        while(m<n){
            n=n&(n-1);
        }
        return n;
    }
};

</code></pre></details>

## [汉明距离](https://leetcode-cn.com/problems/hamming-distance/)
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和 y，计算它们之间的汉明距离。

>输入: x = 1, y = 4
输出: 2

<details><summary>查看代码</summary><pre><code>
//汉明距离即是异或后的1的个数，然后用Brian Kernighan 算法快速统计1的个数
class Solution {
public:
    int hammingDistance(int x, int y) {
        int ans=0;
        int Xor = (x ^ y);
        while(Xor!=0){
          Xor=Xor&(Xor-1);
          ans++;
        }
        return ans;
    }
};
</code></pre></details>

## [数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

>输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]

<details><summary>查看代码</summary><pre><code>
/*出现两次的数异或等于0，若仅存在一个出现一次的数直接异或即为答案；因此本题将数组分为两组分别含有一个出现一次的数然后异或。
所有数异或，若某一位为1则只可能是两个出现一次的数异或的结果，根据这一位分成两组（两个出现一次的数在此位不同）
*/
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        int res = 0, r = 1, ans1 = 0, ans2 = 0;
        for (int num : nums) {
            res ^= num;//异或
        }
        while (!(res & r))//找到为1的bit
        {
            r = r << 1;
        }
        for (int num : nums) {
            if (num & r)//根据为1的bit分成两组分别异或
                ans1 ^= num;
            else ans2 ^= num;
        }
        return vector<int>{ans1, ans2};
    }
};
</code></pre></details>

## [数组中数字出现的次数 II](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)
在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

>输入：nums = [3,4,3,3]
输出：4

<details><summary>查看代码</summary><pre><code>
/*
出现三次的数每一位上相加取余3为零，即所有数字按位加然后每位取余3即为答案；
*/
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int a[32]{ 0 }, ans = 0;//数组保存每位的和
        for (int num : nums) {
            size_t r = 1;
            for (int i = 0; i < 32; i++) {
                a[i] += num & r;
                num = num >> 1;//每次右移一位
            }
        }
        int m = 3;
        for (int i = 0; i < 32; i++) {
            a[i] = a[i] % m;//各bit位取余3
            ans = ans | (a[i] << i);//a[i]左移i位即为在答案中的bit位，然后与ans按位或即可
        }
        return ans;
    }
};
</code></pre></details>

## 干扰整数（华为笔试）
给定n个无符号整数，进行二进制移位和调换进行干扰，干扰后仍是n个无符号整数。
干扰操作：
1.每个整数每两个bit位交换，如bit0和bit1交换，bit2和bit3交换；
2.每个整数右移两位，第一个整数右移溢出的两位补到第二个整数最高两bit上，第二个整数右移溢出的两位补到第三个整数最高两bit上，第n个整数右移溢出的两位补到第一个整数最高两bit上。

>1 2
1073741824 2147483648

<details><summary>查看代码</summary><pre><code>
//直接进行模拟
#include <iostream>
#include <vector>

using namespace std;

unsigned int huHuan(unsigned int num) {
    unsigned int ans = 0, r = 1;
    for (int i = 0; i < 16; i++) {
        ans = ans | (num & r) << 1;
        r = r << 1;
        ans = ans | (num & r) >> 1;
        r = r << 1;
    }
    return ans;
}

int main() {
    vector<unsigned int> nums;
    unsigned int temp;
    while (cin >> temp)
    {
        nums.push_back(temp);
        if (cin.get() == '\n')
            break;
    }
    vector<unsigned int> pre(nums.size());
    unsigned int r = 3;
    for (int i = 0; i < nums.size(); i++) {
        nums[i] = huHuan(nums[i]);
    }
    pre[0] = nums[0] & r;
    nums[0] = nums[0] >> 2;
    pre[0] = pre[0] << 30;
    for (int i = 1; i < nums.size(); i++) { 
        pre[i] = nums[i] & r;
        nums[i] = nums[i] >> 2;
        pre[i] = pre[i] << 30;
    }
    for (int i = 1; i < nums.size(); i++)
        nums[i] = nums[i] | pre[i-1];
    nums[0] = nums[0] | pre[nums.size() - 1];
    for (int i = 0; i < nums.size() - 1; i++) {
        cout << nums[i] << " ";
    }
    cout << nums[nums.size() - 1] << endl;
	return 0;
}
</code></pre></details>