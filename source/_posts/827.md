---
title: '827'
date: 2022-09-18 23:30:22
categories:
- leetcode
mathjax: true
tag:
- DFS
- 并查集
---

给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。

返回执行此操作后，grid 中最大的岛屿面积是多少？

岛屿 由一组上、下、左、右四个方向相连的 1 形成。

### 示例 1:

输入: grid = [[1, 0], [0, 1]]
输出: 3
解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。
示例 2:

输入: grid = [[1, 1], [1, 0]]
输出: 4
解释: 将一格0变成1，岛屿的面积扩大为 4。
示例 3:

输入: grid = [[1, 1], [1, 1]]
输出: 4
解释: 没有0可以让我们变成1，面积依然为 4。

<details><summary>查看代码</summary><pre><code>
// dfs
class Solution {
    static int dir[][2];
    bool invaild(int n, int x, int y) {
        return x < 0 || x >= n || y < 0 || y >= n;
    }
    int dfs(vector<vector<int>>& grid, int x, int y, vector<vector<int>>& tag, int t) {
        int area = 1;
        tag[x][y] = t;
        for (int i = 0; i < 4; i++) {
            int next_x = x + dir[i][0];
            int next_y = y + dir[i][1];
            if (invaild(grid.size(), next_x, next_y) || grid[next_x][next_y] == 0 ||
                tag[next_x][next_y] != 0) {
                continue;
            }
            area += dfs(grid, next_x, next_y, tag, t);
        }
        return area;
    }
public:
    int largestIsland(vector<vector<int>>& grid) {
        int ans = 0;
        int n = grid.size();
        vector<vector<int>> tag(n, vector<int>(n, 0));
        vector<int> area(n * n + 1, 0);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1 && tag[i][j] == 0) {
                    int t = i * n + j + 1;
                    area[t] = dfs(grid, i, j, tag, t);
                    ans = max(ans, area[t]);
                }
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                unordered_set<int> hashSet;
                if (grid[i][j] == 1) continue;
                int sum = 1;
                for (int k = 0; k < 4; k++) {
                    int next_x = i + dir[k][0];
                    int next_y = j + dir[k][1];
                    if (!invaild(grid.size(), next_x, next_y) && tag[next_x][next_y] != 0 && hashSet.count(tag[next_x][next_y]) == 0) {
                        sum += area[tag[next_x][next_y]];
                        hashSet.insert(tag[next_x][next_y]);
                    }
                }
                ans = max(ans, sum);
            }
        }
        return ans;
    }
};
int Solution::dir[][2] = { {1, 0}, {0, 1}, {-1, 0}, {0, -1} };
// 并查集解法
class Solution {
    static int dir[][2];
    vector<int> area;
    vector<int> parents;
    bool invaild(int n, int x, int y) {
        return x < 0 || x >= n || y < 0 || y >= n;
    }
    int find(int x) {
        if (parents[x] != x) parents[x] = find(parents[x]);
        return parents[x];
    }
    void unionSet(int x, int y) {
        int px = find(x), py = find(y);
        if (px == py) {
            return;
        }
        if (area[px] < area[py]) {
            unionSet(y, x);
        }
        else {
            parents[px] = parents[py];
            area[py] += area[px];
        }
    }
public:
    int largestIsland(vector<vector<int>>& grid) {
        int ans = 0;
        int n = grid.size();
        area.resize(n * n + 1);
        parents.resize(n * n + 1);
        for (int i = 0; i < n * n + 1; i++) {
            parents[i] = i;
            area[i] = 1;
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) continue;
                for (int k = 0; k < 4; k++) {
                    int next_x = i + dir[k][0], next_y = j + dir[k][1];
                    if (!invaild(grid.size(), next_x, next_y) && grid[next_x][next_y] == 1) {
                        unionSet(i * n + j + 1, next_x * n + next_y + 1);
                    }
                }
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    ans = max(ans, area[find(i * n + j + 1)]);
                    continue;
                }
                int sum = 1;
                unordered_set<int> hashSet;
                for (int k = 0; k < 4; k++) {
                    int next_x = i + dir[k][0];
                    int next_y = j + dir[k][1];
                    int t = next_x * n + next_y + 1;
                    if (!invaild(grid.size(), next_x, next_y) && hashSet.count(find(t)) == 0 && grid[next_x][next_y] != 0) {
                        sum += area[find(t)];
                        hashSet.insert(find(t));
                    }
                }
                ans = max(ans, sum);
            }
        }
        return ans;
    }
};
int Solution::dir[][2] = { {1, 0}, {0, 1}, {-1, 0}, {0, -1} };
</code></pre></details>

REF:[力扣（LeetCode）](https://leetcode.cn/problems/making-a-large-island)