---
title: 双指针
date: 2020-08-19 16:22:10
mathjax: true
tags:
- 双指针
---
## [和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)
输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

<details><summary>查看代码</summary><pre><code>
//双指针分别指向两端
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int p1 = 0, p2 = nums.size() - 1;
        while (p1 <= p2) {
            if (nums[p1] + nums[p2] < target) {//小于则p1+1
                p1++;
            }else if (nums[p1] + nums[p2] > target) {//大于则p2-1
                p2--;
            }
            else {//相等则返回结果
                return vector<int>{nums[p1], nums[p2]};
            }
        }
        return vector<int>{};
    }
};
</code></pre></details>

## [三数之和](https://leetcode-cn.com/problems/3sum/)

<details><summary>查看代码</summary><pre><code>
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            if (i-1>=0&&nums[i] == nums[i - 1])continue;
            if (nums[i] <= 0) {
                int l = i + 1, r = nums.size()-1;
                while (l < r) {
                    if (nums[l] + nums[i] + nums[r] == 0) {
                        ans.push_back(vector<int>{nums[l], nums[i], nums[r]});
                        while (l + 1 < r && nums[l + 1] == nums[l]) {
                            l++;
                        }
                        while (r - 1 > l&& nums[r - 1] == nums[r]) {
                            r--;
                        }
                        l++;
                        r--;
                    }
                    else if (nums[l] + nums[i] + nums[r] > 0) {
                        r--;
                    }
                    else l++;
                }
            }
        }
        return ans;
    }
};
</code></pre></details>

## [滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)
给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。

>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 
  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

 <details><summary>查看代码</summary><pre><code>
 //双端队列维护最大值
 class Solution {
private:
    deque<int> max;
    vector<int> ans;
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        if(nums.size()==0)return ans;
        for (int i = 0; i < k; i++) {
            while (!max.empty() && nums[i] > max.front())max.pop_front();
            max.push_front(nums[i]);
        }
        for (int i = 0; i < nums.size() - k + 1; i++) {
            ans.push_back(max.back());
            if (nums[i] == max.back())max.pop_back();
            if (i + k < nums.size()) {
                while (!max.empty() && nums[i + k] > max.front())max.pop_front();
                max.push_front(nums[i + k]);
            }
        }
        return ans;
    }
};
 </code></pre></details>