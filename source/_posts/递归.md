---
title: 递归
date: 2020-08-01 16:22:10
mathjax: true
tags:
- 递归
---

## 数值的整数次方
> 实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题，n可以是负数。

<details><summary>查看代码</summary><pre><code>
class Solution {
public:
    double myPow(double x, int n) {
        if(n==0)return 1;
        if(n==1)return x;
        if(n==-1)return 1/x;
        double t = myPow(x,n/2);//二分调用myPow(x,n/2)并记录以减少重复计算
        return t*t*myPow(x,n%2);
    }
};
</code></pre></details>

## 如何查找两个有序数组的中位数


## 字符串的排列
不能有重复元素

<details><summary>查看代码</summary><pre><code>
class Solution {
private:
    int len;
    vector<string> ans;
public:
    void helper(string s,int left){
        if(left==len-1)ans.push_back(s);
        vector<char> tmp;
        for(int i=left;i<len;i++){
            if(find(tmp.begin(),tmp.end(),s[i])==tmp.end()){//若存在则说明已交换过相同字符
                tmp.push_back(s[i]);//加入临时数组，说明已与该符号交换
                swap(s[left],s[i]);
                helper(s,left+1);0
                swap(s[left],s[i]);
            }
        }
    }
    vector<string> permutation(string s) {
        int i=0,j;
        len=s.length();
        j=len-1;
        helper(s,0);
        return ans;
    }
};
</code></pre></details>

## 数组小和
归并

<details><summary>查看代码</summary><pre><code>
#include<iostream>
#include<vector>
#include<deque>
using namespace std;

int ans = 0;
vector<int> nums;

void merge(int l, int r,int mid) {
	if (l > r)return;
	int len = r - l + 1, * temp = new int[len];
	int i = l, j = mid + 1, k = 0;
	while (i <= mid && j <= r) {
		if (nums[i] <= nums[j]) {
			ans += nums[i] * (r - j + 1);
			temp[k++] = nums[i++];
		}
		else {
			temp[k++] = nums[j++];
		}
	}
	while (i <= mid) {
		temp[k++] = nums[i++];
	}
	while (j <= r) {
		temp[k++] = nums[j++];
	}
	for (int k = 0; k < len; k++) {
		nums[l++] = temp[k];
	}
}

void sort(int l,int r) {
	if (l >= r)return;
	sort(l, (l + r) >> 1);
	sort(((l + r) >> 1) + 1, r);
	merge(l, r, (l + r) >> 1);
}

int main()
{
	long long n;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		int t;
		cin >> t;
		nums.push_back(t);
	}
	sort(0, nums.size() - 1);
	cout << ans << endl;
	return 0;
}
</code></pre></details>

## [24 点游戏](https://leetcode-cn.com/problems/24-game/)
你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。

>输入: [4, 1, 8, 7]
输出: True
解释: (8-4) * (7-1) = 24

<details><summary>查看代码</summary><pre><code>
//递归遍历所有可能
class Solution {
    static constexpr int TARGET = 24;
    static constexpr double EPSILON = 1e-6;
    static constexpr int ADD = 0, MULTIPLY = 1, SUBTRACT = 2, DIVIDE = 3;

public:
    bool helper(vector<double> &l) {
        if (l.size() == 0)return false;
        if (l.size() == 1)return fabs(l[0] - TARGET) < EPSILON;
        int size = l.size();
        for (size_t i = 0; i < size; i++)
        {
            for (size_t j = 0 ; j < size; j++)
            {
                if (i != j) {
                    vector<double> l2;
                    for (int k = 0; k < size; k++) {
                        if (k != i && k != j) {
                            l2.push_back(l[k]);
                        }
                    }
                    for (int k = 0; k < 4; k++) {
                        if (k == ADD) {
                            l2.push_back(l[i] + l[j]);
                        }
                        else if (k == MULTIPLY) {
                            l2.push_back(l[i] * l[j]);
                        }
                        else if (k == SUBTRACT) {
                            l2.push_back(l[i] - l[j]);
                        }
                        else if (k == DIVIDE) {
                            if (l[j] < EPSILON)continue;
                            else l2.push_back(l[i] / l[j]);
                        }
                        if (helper(l2))return true;
                        l2.pop_back();
                    }
                }
            }
        }
        return false;
    }
    bool judgePoint24(vector<int>& nums) {
        vector<double> l;
        for (int num : nums)
        {
            l.push_back(static_cast<double>(num));
        }
        return helper(l);
    }
};
</code></pre></details>

## [求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)
求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

>输入: n = 3
输出: 6

<details><summary>查看代码</summary><pre><code>
class Solution {
public:
    int res=0;
    int sumNums(int n) {
       bool t = (n==1||sumNums(n-1));//利用逻辑运算的短路原则终止递归
       res+=n;//递归实现1+2+...+n
       return res;
    }
};
</code></pre></details>

## [圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)
0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

>输入: n = 5, m = 3
输出: 3

<details><summary>查看代码</summary><pre><code>
class Solution {
public:
    int lastRemaining(int n, int m) {
        if (n == 1)return 0;
        return (lastRemaining(n - 1, m) + m) % n;
    }
};
</code></pre></details>

## 递增子序列
给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。

>输入: [4, 6, 7, 7]
输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]

<details><summary>查看代码</summary><pre><code>
class Solution {
private:
    int len;
    vector<vector<int>> ans;
    vector<int > temp;
public:
    bool cmp(const vector<int>& nums, int last, int cur) {//关键去重
        for (int i = last + 1; i < cur; i++) {
            if (nums[i] == nums[cur]) {
                return false;
            }
        }
        return true;
    }
    void helper(const vector<int>& nums,const int &l,const int &r,const int &_len,const int &pre) {
        if (_len > 1)ans.push_back(temp);
        if (l == r) {
            return ;
        }
        for (int i = l; i < r; i++) {
            if ((temp.size()==0|| nums[i] >= nums[pre])&&cmp(nums, pre, i)) {
                temp.push_back(nums[i]);
                helper(nums, i + 1, r, _len + 1, i);
                temp.pop_back();
            }
        }
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        helper(nums, 0, nums.size(), 0, -1);
        return ans;
    }
};
</code></pre></details>

## [电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

>输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

<details><summary>查看代码</summary><pre><code>
//dfs深搜回溯所有组合
class Solution {
private:
	vector<string> str = { "abc","def","ghi","jkl","mno","pqrs","tuv","wxyz" };
	vector<string> ans;
	string s;
	int n;
public:
	void helper(const string& digits, const int& index) {
		if (index == n) {
			ans.push_back(s);
			return;
		}
		for (int i = 0; i < str[digits[index] - '2'].size(); i++) {
			s.push_back(str[digits[index] - '2'][i]);
			helper(digits,index + 1);
			s.pop_back();
		}
	}
	vector<string> letterCombinations(string digits) {
		n = digits.size();
		if (n == 0)return ans;
		helper(digits, 0);
		return ans;
	}
};
</code></pre></details>

## [括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
<details><summary>查看代码</summary><pre><code>
//深搜递归，递归"("判断是否还有"(",递归")"判断是否有")"可用以及是否还有"("可以匹配
class Solution {
private:
    vector<string> ans;
    string t;
    int numOfl, numOfr, nowOfl;
public:
    void helper(const int &l,const int &len) {
        if (l == len) {
            ans.push_back(t);
            return;
        }
        if (numOfl > 0) {
            numOfl--;
            nowOfl++;
            t = t + "(";
            helper(l+1,len);
            t.pop_back();
            nowOfl--;
            numOfl++;
        }
        if (numOfr > 0 && nowOfl > 0) {
            numOfr--;
            nowOfl--;
            t = t + ")";
            helper(l + 1, len);
            t.pop_back();
            numOfr++;
            nowOfl++;
        }
    }
    vector<string> generateParenthesis(int n) {
        t = "";
        numOfl = n;
        numOfr = n;
        nowOfl = 0;
        helper(0, 2 * n);
        return ans;
    }
};
</code></pre></details>