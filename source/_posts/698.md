---
title: '698'
date: 2022-09-20 22:30:22
categories:
- leetcode
mathjax: true
tag:
- 排序
- dfs
- bitmap

---

给定一个整数数组 `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。

#### 示例 1：

```
输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4
输出： True
说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。
```
#### 示例 2:
```
输入：nums = [1,2,3,4], k = 3
输出：False
```

<details><summary>查看代码</summary><pre><code>
class Solution {
    int gk;
    int avg;
    int n;
    bool dfs(int idx, int cur, int cnt, vector<bool> &visited, vector<int>& nums) {
        if (cur == avg) {
            return dfs(0, 0, cnt + 1, visited, nums);
        }
        // 因为各分组的和与原数组相等，到这所有元素必然已使用
        if (cnt == gk) {
            return true;
        }
        // 从大到小搜索
        for (int i = idx; i < n; i++) {
            if (cur + nums[i] > avg) continue;
            if (visited[i] == true) continue;
            visited[i] = true;
            if (dfs(i + 1, cur + nums[i], cnt, visited, nums)) {
                return true;
            }
            visited[i] = false;
            if (cur == 0) return false; // 当前最大单个元素无法加入任何子集，此种方案false
        }
        return false;
    }
public:
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        n = nums.size();
        gk = k;
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if (sum % k != 0) return false;
        avg = sum / k;
        sort(nums.begin(), nums.end(), greater<int>());
        vector<bool> visited(n, false);
        return dfs(0, 0, 0, visited, nums);
    }
};
</code></pre></details>

待补充官方题解，利用bitmap记录当前元素是否已访问，则可以用一个整数S表示当前已经加入子集的元素（当前状态），继而可以使用vis[S]标记当前状态是否已计算，避免重复计算


<details><summary>查看代码</summary><pre><code>
class Solution {

  int gk;

  int avg;

  int n;

  bool dfs(int s, int cur, vector<bool> &visited, const vector<int>& nums) {

​    if (cur == avg) cur = 0;

​    if (s == 0) return true;

​    if (!visited[s]) return false;

​    

​    visited[s] = false;

​    for (int i = 0; i < n; i++) {

​      if (cur + nums[i] > avg) break;

​      if (s >> i& 1)

​        if (dfs(s ^ (1 << i), cur + nums[i], visited, nums)) return true;

​    }

​    return false;

  }

public:

  bool canPartitionKSubsets(vector<int>& nums, int k) {

​    n = nums.size();

​    gk = k;

​    int sum = accumulate(nums.begin(), nums.end(), 0);

​    if (sum % k != 0) return false;

​    avg = sum / k;

​    sort(nums.begin(), nums.end());

​    vector<bool> visited(1 << n, true);

​    return dfs((1 << n) - 1, 0, visited, nums);

  }

};
</code></pre></details>

[698. 划分为k个相等的子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)