---
title: 并查集
date: 2020-08-22 16:22:10
mathjax: true
tags:
- 并查集
---
```c++
int pre[N],rank[N]; //pre[]为前驱,rank[]为当前元素所在集合的大小
 
//初始化
void Init()
{
    for(int i=0; i<N; i++)
    {
        pre[i] = i;
        rank[i] = 1;
    }
}
 
//带路径压缩的非递归找根节点
int Find(int x)
{
    int r = x;
    while(r != pre[r])
        r = pre[r];
    int i = x, j;
    while(i != r)
    {
        j = pre[i];
        pre[i] = r;
        i = j;
    }
    return r;
}
 
//带路径压缩的递归找根节点
int Find(int x)
{
    if(pre[x] != x)
        pre[x] = Find(pre[x]);
    return pre[x];
}
 
//按秩合并，元素少的集合的根节点指向元素多的集合的根节点
void Union(int x,int y)
{
    x = Find(x);
    y = Find(y);
    if(x == y) return;
    if(rank[x] >= rank[y])
    {
        pre[y] = x;
        rank[x] += rank[y];
    }
    else
    {
        pre[x] = y;
        rank[y] += rank[x];
    }
}
```

## [冗余连接](https://leetcode-cn.com/problems/redundant-connection/submissions/)
输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。
结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u < v，表示连接顶点u 和v的无向图的边。
返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u < v。

>输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的无向图为:
  1
 / \
2 - 3

<details><summary>查看代码</summary><pre><code>
class Solution {
public:
	int maxn, cnt;
	int* pre;
	void new_set()
	{
		for (int i = 1; i <= maxn; i++) {
			pre[i] = i;
		}
	}
	int Find(int x)
	{
		int r = x;
		while (r != pre[r])
			r = pre[r];
		int i = x, j;
		while (i != r)
		{
			j = pre[i];
			pre[i] = r;
			i = j;
		}
		return r;
	}
	bool union_set(int x, int y)
	{
		x = Find(x);
		y = Find(y);
		if (x == y) {
			return true;
		}
		else {
			pre[x] = y;
		}
		return false;
	}
	vector<int> findRedundantConnection(vector<vector<int>>& edges) {
		maxn = edges.size();
		pre = new int[maxn + 1];
		new_set();
		for (int i = 0; i < maxn + 1; i++) {
			if (union_set(edges[i][0], edges[i][1]))return edges[i];
		}
		return vector<int>{};
    }
};
</code></pre></details>

## [顺丰笔试：学术交流]

<details><summary>查看代码</summary><pre><code>
#include "stdafx.h"

int* pre;

int Find(int x)
{
	int r = x;
	while (r != pre[r])
		r = pre[r];
	int i = x, j;
	while (i != r)
	{
		j = pre[i];
		pre[i] = r;
		i = j;
	}
	return r;
}

int main() {
	int n, m, k, t1, t2, ans = 0;
	cin >> n >> m >> k;
	unordered_set<int> s;
	vector<vector<int>> persons(n + 1);
	int *visited = new int[m + 1];
	memset(visited, 0, sizeof(int) * (m + 1));
	pre = new int[m + 1];
	memset(pre, 0, sizeof(int) * (m + 1));
	for (int i = 0; i < k; i++) {
		cin >> t1 >> t2;
		pre[t2] = t2;
		persons[t1].push_back(t2);
	}

	for (int i = 1; i <= n; i++) {
		for (size_t j = 1; j < persons[i].size(); j++)
		{
			if (visited[persons[i][j]] == 0 && Find(persons[i][0]) != Find(persons[i][j])) {
				pre[persons[i][j]] = pre[persons[i][0]];
				visited[persons[i][j]] == 1;
			}
		}
		if (persons[i].size() == 0)ans++;
	}

	for (int i = 1; i <= m; i++) {
		if (pre[i] == 0);
		else {
			if (s.find(Find(i)) != s.end());
			else {
				s.insert(Find(i));
				ans++;
			}
		}
	}
	cout << ans - 1 << endl;
    return 0;
}
</code></pre></details>

## [等式方程的可满足性](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/)

<details><summary>查看代码</summary><pre><code>
class Solution {
    int* m1;
public:
    int find(int* m, int num) {
        int r = num;
        while (r != m[r])r = m[r];
        int i = num, j;
        while (i != r) {
            j = m[i];
            m[i] = r;
            i = j;
        }
        return r;
    }
    void Union(int* m, int a, int b) {
        int x = find(m, a);
        int y = find(m, b);
        if (x != y) {
            m[x] = y;
        }
    }
    bool equationsPossible(vector<string>& equations) {
        m1 = new int[26];
        for (int i = 0; i < 26; i++) {
            m1[i] = i;
        }
        for (int i = 0; i < equations.size(); i++) if (equations[i][1] == '=')Union(m1, equations[i][0] - 'a', equations[i][3] - 'a');
        for (int i = 0; i < equations.size(); i++) {
            if (equations[i][1] == '!') {
                if (find(m1, equations[i][0] - 'a') == find(m1, equations[i][3] - 'a'))return false;
            }
        }
        return true;
    }
};
</code></pre></details>