---
title: 搜索
date: 2020-08-01 16:22:10
mathjax: true
tags:
- 搜索
---

## Sticks
N个棍子，长度为len[n]，棍子可以拼接成更长的棍子，要求所有的棍子都使用，且拼成的长度相等为m，求最短长度m;例子：
输入: 5,2,1,5,2,1,5,2,1
输出：6

<details><summary>查看代码</summary><pre><code>
class solution {
/*
* cur : 当前从第cur根棍子开始尝试组合
* nums : 当前还有nums根新棍子未组合完成
* curLen ：当前组合的棍子长度
* len ： 要组合的新棍子长度
*/
private:
    const int INF = 1 << 30;
    const int N = 70;
    vector<int> stick;
    int visit[70];
    int n;
    int ans;
public:
    bool dfs(int cur, int nums, int curLen, int len)
    {
        if (nums == 0)
            return true;
        int same = -1;
        for (int i = cur; i < n; i++)
        {
            if (visit[i] || stick[i] == same)//剪枝2：当前长度的棍子不合适，直接跳过
                continue;
            visit[i] = 1;
            if (curLen + stick[i] < len)
            {
                if (dfs(cur + 1, nums, curLen + stick[i], len))
                    return true;
                else same = stick[i];
            }
            else if (curLen + stick[i] == len)
            {
                if (dfs(0, nums - 1, 0, len))
                    return true;
            }
            visit[i] = 0;
            if (curLen == 0)break;//剪枝3：cur作为组合的第一个棍子，与其他所有棍子不合适，跳过以cur开始的组合
        }
        return false;
    }
    int findMinLen() {
        cin >> n;
        int sum = 0, ans = 0;
        stick.clear();
        for (int i = 0; i < n; i++)
        {
            int len;
            cin >> len;
            sum += len;
            stick.push_back(len);
        }

        ans = INF;
        sort(stick.begin(), stick.end(), [](int a, int b) {return a > b; });
        for (int i = stick[0]; i <= sum; i++)
        {
            if (sum % i != 0)//剪枝1：最后的长度一定会被棍子总和整除
                continue;
            memset(visit, 0, sizeof(visit));
            if (dfs(0, sum / i, 0, i))
            {
                ans = i;
                break;
            }
        }
        return ans;
    }
};
</code></pre></details>

## 矩阵的路径 
判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子

> dfs深搜遍历所有路径，注意标志矩阵的设置

<details><summary>查看代码</summary><pre><code>
class Solution {
private:
    int n,m,M,dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
    bool  **visited;
public:
    bool helper(const vector<vector<char>>& board,const string &word,const int &index,const int &i,const int &j){
       if (index == M)return true;
        for (int k = 0; k < 4; k++) {
            int _i = i + dir[k][0], _j = j + dir[k][1];
            if (_i >= 0 && _i < n && _j >= 0 && _j < m && !visited[_i][_j] && board[_i][_j] == word[index]) {
                visited[_i][_j] = true;//进递归，置为true
                if(helper(board, word, index+1, _i, _j))return true;
                visited[_i][_j] = false;//出递归，置为false
            }
        }
        return false;
    }
    bool exist(vector<vector<char>>& board, string word) {
        M = word.size();
        if (M == 0)return true;
        n = board.size();
        if (n == 0)return false;
        m = board[0].size();
        visited = new bool*[n];
        for (int i = 0; i < n; i++) {
            visited[i] = new bool[m];
            memset(visited[i], false, sizeof(bool) * m);
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (word[0] == board[i][j]) {
                    visited[i][j] = true;
                    if (helper(board, word, 1, i, j))return true;
                    visited[i][j] = false;
                }
            }
        }
        return false;
    }
};
</code></pre></details>

## 机器人路径 
地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

>  dfs深搜遍历所有可以走的路径，每个节点只走一次，标志矩阵置为true后不置为false

<details><summary>查看代码</summary><pre><code>
class Solution {
private:
    int rows,cols,threshold,dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
    bool visit[100][100];
public:

    int getSum(int rows,int cols){
        int sum=0;
        while(rows!=0){
            sum+=(rows%10);
            rows/=10;
        }
        while(cols!=0){
            sum+=(cols%10);
            cols/=10;
        }
        return sum;
    }
    
    void moving(int i,int j,int &num){
        if (visit[i][j] == false) {
    	    num++;
    	    visit[i][j] = true;//只置为true，不置回false
        }
        for (int k = 0; k < 4; k++) {
            int _i = i + dir[k][0], _j = j + dir[k][1];
            if (_i >= 0 && _i < rows && _j >= 0 && _j < cols && !visit[_i][_j] && getSum(_i, _j) <= threshold)
            moving(_i, _j, num);
        }
    }
    
    int movingCount(int m, int n, int k) {
        int num=0;
        rows=m;
        cols=n;
        threshold=k;
        memset(visit,0,100*100*sizeof(bool));
        if(getSum(0,0)<=k)moving(0,0,num);
        return num;
    }
};
</code></pre></details>

## 复原IP地址

> 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 '.' 分隔。
遍历搜索'.'所有可能的位置，并利用helper判断是否合法
<details><summary>查看代码</summary><pre><code>
class Solution {
public:
    bool helper(string s) {
        if (s.length() == 0)return false;
        if (s.length() == 1)return true;
        if (s.length() > 3)return false;
        if (s[0] == '0')return false;
        if(atoi(s.c_str())>255||atoi(s.c_str())<0)return false;
        return true;
    }
    vector<string> restoreIpAddresses(string s) {
        vector<string> ans;
        int n = s.size();
        string p1, p2, p3, p4;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                for (int k = 0; k < 3; k++) {
                        p1 = s.substr(0, i + 1).c_str();
                        p2 = i + 1 < n ? s.substr(i + 1, j + 1) : "";
                        p3 = i + j + 2 < n ? s.substr(i + j + 2, k + 1) : "";
                        p4 = i + j + k + 3 < n ? s.substr(i + j + k + 3) : "";
                        if (helper(p1)&& helper(p2)&& helper(p3)&& helper(p4)) {
                            ans.push_back(p1+"."+ p2 + "." + p3 + "." + p4);
                        }
                }
            }

        }
        return ans;
    }
};
</code></pre></details>

## 找出满足最大值减去最小值小于等于num的子数组数量

max(arr[i...j]) - min(arr[i...j]) <= num
max(arr[i...j])表示子数组arr[i...j]中的最大值，min[arr[i...j])表示子数组arr[i...j]中的最小值

<details><summary>查看代码</summary><pre><code>
#include<iostream>
#include<vector>
#include<deque>
using namespace std;
int main()
{
	long long n; long long num;
	cin >> n >> num;
	vector<long long> datas(n, 0);
	for (int i = 0; i < n; i++)
	{
		long long x;
		cin >> x;
		datas[i] = x;
	}
	//以上用于输入
	deque<int> dq1;//最大值队列
	deque<int> dq2;//最小值队列
	int res = 0;
	int j = 0;
	int i = 0;
	for (; i < datas.size(); i++)
	{ //以i为起始位置的子数组
		for (; j < datas.size(); j++)
		{
			while (!dq1.empty() && datas[j] >= datas[dq1.back()])
				dq1.pop_back();
			dq1.push_back(j);
			while (!dq2.empty() && datas[j] <= datas[dq2.back()])
				dq2.pop_back();
			dq2.push_back(j);
			//如果最大值减去最小值大于num就break，此时最大值
			//减去最小值大于num一定是由于j的插入
			if (datas[dq1.front()] - datas[dq2.front()] > num)
				break;
		}
		if (dq1.front() == i)//如果队头是i位置的元素，i加一后就过期删掉
			dq1.pop_front();
		if (dq2.front() == i)
			dq2.pop_front();
		res += j - i;//以i为开头的小于num的子数组长度j-i
	}
	cout << res << endl;
}
</code></pre></details>

## 数字序列中某一位的数字
数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

<details><summary>查看代码</summary><pre><code>
class Solution {
public:
    int findNthDigit(int n) {
        int digit = 1;
        long start = 1;
        long count = 9;
        while (n > count) { 
            n -= count;
            digit += 1;
            start *= 10;
            count = digit * start * 9;
        }
        long num = start + (n - 1) / digit; 
        return to_string(num)[(n - 1) % digit] - '0'; 
    }
};
</code></pre></details>

## 顺时针遍历
从1开始顺时针报数，若所报数字各位是7，十位是奇数则将下标[i,j]加入数组；

<details><summary>查看代码</summary><pre><code>
#include<iostream>
#include<vector>

using namespace std;

int main() {
	int n, m, k = 0;
	vector<pair<int,int>> ans;
	if (n < 10 || n>1000 || m < 10 || m>1000) {
		cout << "[]" << endl;
		return 0;
	}
	cin >> n >> m;
	int row = 0, col = 0, xl = 0, xr = m - 1, yu = 0, yd = n - 1, dir = 0;
	while (k < n * m) {
		if (dir == 0) {
			for (col = xl; col <= xr; col++) {
				k++;
				if ((k % 10 == 7) && (((k % 100) / 10) % 2 == 1))
					ans.push_back(make_pair(row, col));
			}
			yu++;
			dir = 1;
			col--;
		}
		else if (dir == 1) {
			for (row = yu; row <= yd; row++) {
				k++;
				if ((k % 10 == 7) && (((k % 100) / 10) % 2 == 1))
					ans.push_back(make_pair(row, col));
			}
			xr--;
			dir = 2;
			row--;
		}
		else if (dir == 2) {
			for (col = xr; col >= xl; col--) {
				k++;
				if ((k % 10 == 7 )&& (((k % 100) / 10) % 2 == 1))
					ans.push_back(make_pair(row, col));
			}
			yd--;
			dir = 3;
			col++;
		}
		else {
			for (row = yd; row >= yu; row--) {
				k++;
				if ((k % 10 == 7) && (((k % 100) / 10) % 2 == 1))
					ans.push_back(make_pair(row, col));
			}
			xl++;
			dir = 0;
			row++;
		}
	}
	for (int i = 0; i < ans.size() - 1; i++) {
		cout << "[" << ans[i].first << "," << ans[i].second << "],";
	}
	cout<< "[" << ans[ans.size() - 1].first << "," << ans[ans.size() - 1].second << "]";
	return 0;
}
</code></pre></details>

## [构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)
给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

>输入: [1,2,3,4,5]
输出: [120,60,40,30,24]

<details><summary>查看代码</summary><pre><code>
class Solution {
public:
    vector<int> constructArr(vector<int>& a) {
        vector<int> ans(a.size(), 1), dp(a.size(), 1);
        for (int i = 1; i < a.size(); i++) {
            ans[i] = ans[i - 1] * a[i - 1];

        }
        for (int i = a.size() - 2; i >= 0; i--) {
            dp[i] = dp[i + 1] * a[i + 1];
            ans[i] = ans[i] * dp[i];
        }
        return ans;
    }
};
</code></pre></details>

## [不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)
写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

>输入: a = 1, b = 1
输出: 2

<details><summary>查看代码</summary><pre><code>
class Solution {
public:
    int add(int a, int b) {
        int t;
        while(b!=0){//无进位终止
            t = (unsigned int) (a & b)<<1;//进位：按位与后左移1位
            a = a ^ b;//当前不考虑进位，若有进位则在下一循环相加
            b = t;
        }
        return a;
    }
};
</code></pre></details>

## [重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)
给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

>输入: "abab"
输出: True
解释: 可由子字符串 "ab" 重复两次构成。

<details><summary>查看代码</summary><pre><code>
class Solution {//暴力搜索，优化见leetcode
public:
    bool repeatedSubstringPattern(string s) {
        bool match;
        for (int i = 1; i*2 <= s.size(); i++) {
            if (s.size() % i != 0)continue;
            match = true;
            for (int j = i; j < s.size(); j++) {
                if (s[j] != s[j - i]) {
                    match = false;
                    break;
                }
            }
            if (match)return true;
        }
        return false;
    }
};
</code></pre></details>

## [柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
求在该柱状图中，能够勾勒出来的矩形的最大面积。

>输入: [2,1,5,6,2,3]
输出: 10

<details><summary>查看代码</summary><pre><code>
//按高度进行穷搜
class Solution {
private:
    long long Max = INT_MIN;
public:
    int largestRectangleArea(vector<int>& heights) {
        if(heights.empty())return 0;
        for (int i = 0; i < heights.size(); i++) {
            long long l = i, r = i + 1;
            while (l - 1 >= 0 && heights[l - 1] >= heights[i]) l--;
            while (r < heights.size() && heights[r] >= heights[i]) r++;
            Max = max(Max, (r - l) * heights[i]);
        }
        return Max;
    }
};
//辅助数据结构栈、数组存储有效数据，空间换时间
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size(), Max = 0;
        vector<int> left(n), right(n, n);
        stack<int> s;
        for (int i = 0; i < heights.size(); i++) {
            while (!s.empty() && heights[s.top()] > heights[i]) {
                right[s.top()] = i;
                s.pop();
            }
            left[i] = !s.empty() ? s.top() : -1;
            s.push(i);
        }
        for (int i = 0; i < heights.size(); i++) {
            Max = max((right[i] - left[i] -  1) * heights[i], Max);
        }
        return Max;
    }
};
</code></pre></details>

## [钥匙和房间](https://leetcode-cn.com/problems/keys-and-rooms/)

有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。最初，除 0 号房间外的其余所有房间都被锁住。你可以自由地在房间之间来回走动。如果能进入每个房间返回 true，否则返回 false。

>输入: [[1],[2],[3],[]]
输出: true
输入：[[1,3],[3,0,1],[2],[0]]
输出：false

<details><summary>查看代码</summary><pre><code>
//DFS深搜（或BFS）
//c++
class Solution {
private:
    int* keys;
public:
    void helper(const vector<vector<int>>& rooms,int index) {
        for (int i = 0; i < rooms[index].size(); i++)
        {
            if (!keys[rooms[index][i]]) {
                keys[rooms[index][i]] = 1;
                helper(rooms, rooms[index][i]);
            }     
        }
    }
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        keys = new int[rooms.size()];
        memset(keys, 0, sizeof(int) * rooms.size());
        keys[0] = 1;
        helper(rooms, 0);
        for (int i = 0; i < rooms.size(); i++) {
            if (!keys[i])return false;
        }
        return true;
    }
};

//python3
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        keys = []
        def dfs(index:int):
            for i in rooms[index]:
                if i not in keys:
                    keys.append(i)
                    dfs(i)
        keys.append(0)
        dfs(0)
        return len(keys) == len(rooms)
</code></pre></details>
