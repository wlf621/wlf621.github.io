---
title: 树算法
date: 2020-08-08 16:22:10
mathjax: true
tags:
- 树算法
---

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

## [利用先序和中序重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

 > 先用线序判断根节点，然后根据根节点和中序划分左右子树，根据左右子树节点数量找到子树对应根节点，继续递归操作

<details><summary>查看代码</summary><pre><code>
class Solution {
public:
    TreeNode* helper(vector<int>::iterator root, vector<int>::iterator inBegin, vector<int>::iterator inEnd) {
    if (inBegin >= inEnd)return nullptr;
    TreeNode* t = new TreeNode(*root);
    vector<int>::iterator tmp = find(inBegin,inEnd,*root);//根据根节点和中序划分左右子树
    t->left = helper(root+1,inBegin,tmp);//左子树根节点为root+1
    t->right = helper(root + (tmp - inBegin + 1), tmp==inEnd?tmp:tmp+1, inEnd);//右子树根节点为root+（左子树节点数量）
    return t;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return helper(preorder.begin(),inorder.begin(),inorder.end());
    }
};
</code></pre></details>

## 组成二叉树的数量
给出每个深度的节点数量，求可能的二叉树的数量

<details><summary>查看代码</summary><pre><code>
#include<iostream>
#include<algorithm>
#include<map>

#define ROW 10001
#define COL 1005

int dp[ROW][COL];
using namespace std;

int main() {
	
	for (int i = 0; i < ROW; i++) {
		
		dp[i][0] = 1;
	}
	for (int i = 0; i < COL; i++)dp[0][i] = 0;
	for (int i = 1; i < COL; i++) {
		for (int j = 1; j < 10001; j++) {
			dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % 1000000007;
		}
	}
	int n, temp, m;
	long long res = 1;
	cin >> n;
	map<int, int> r;
	m = n;
	while (m--) {
		cin >> temp;
		if (r.count(temp))r[temp]++;
		else r[temp] = 1;
	}
	if (r[0] == 0) {
		cout << 0 << endl;
		return 0;
	}
	for (int i = 1; i < r.size(); i++)
		if (r[i] > 2 * r[i - 1])
		{
			return 0;//下一层节点过多直接return
		}
	for (int i = 1; i < r.size(); i++) {
		res *= dp[2*r[i - 1]][r[i]];//坑位2*r[i-1]要放r[i]个，C 2*r[i-1],r[i]；
	}
	cout << res % 1000000007 << endl;
	return 0;
}
</code></pre></details>

## [二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)
给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

<details><summary>查看代码</summary><pre><code>
//利用队列BFS，遇到叶子节点终止遍历
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (!root)return 0;
        queue<TreeNode *> que;
        que.push(root);
        int ans = 0;
        while (!que.empty()) {
            int n = que.size();
            TreeNode* tmp;
            ans++;
            bool flag = false;
            for (size_t i = 0; i < n; i++)
            {
               tmp = que.front();
               que.pop();
               if (!tmp->left && !tmp->right) {
                   flag = true;
                   break;
               }
               else
               {
                   if (tmp->left)que.push(tmp->left);
                   if (tmp->right)que.push(tmp->right);
               }
            }
            if (flag)break;
        }
        return ans;
    }
};

//递归方法
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        if(!root->left&&!root->right)return 1;
        if(!root->left)return minDepth(root->right)+1;
        if(!root->right)return minDepth(root->left)+1;
        int l=minDepth(root->left);
        int r=minDepth(root->right);
        return min(l,r)+1;
    }
};
</code></pre></details>

## [二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先（一个节点也可以是它自己的祖先）。

<details><summary>查看代码</summary><pre><code>
//递归：若两个指定节点的值都大于根，则在右子树；若两个指定节点的值都小于根，则在左子树；其余说明分别在左右子树（或当前节点是某个指定节点）则返回root。

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root->val < p->val && root->val < q->val)return lowestCommonAncestor(root->right, p, q);
        else if (root->val > p->val&& root->val > q->val)return lowestCommonAncestor(root->left, p, q);
        else return root;
    }
};

//遍历，思路相同。
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        TreeNode* cur = root;
        while (cur) {
            if (cur->val < p->val && cur->val < q->val)cur = cur->right;
            else if (cur->val > p->val&& cur->val > q->val)cur = cur->left;
            else break;
        }
        return cur;
    }
};

</code></pre></details>

## [二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

<details><summary>查看代码</summary><pre><code>
//较于二叉搜索树无法通过比较判断节点在哪个子树，可通过递归返回的方式确定所在子树；若某次递归等于指定节点则返回此节点否则返回nullptr，若子树返回的不是nullptr则说明指定节点存在次子树中（或子树存在最近祖先节点），若左右子树都包含指定节点则当前节点是最近祖先节点然后返回，若仅一棵子树返回非空（指定节点或最近祖先节点）则返回子树结果。
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root || root == p || root == q)return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (!left && !right)return root;
        else return !left ? right : left;
    }
};
</code></pre></details>

## [平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)
输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

>给定二叉树 [3,9,20,null,null,15,7]
    3
   / \
  9  20
    /  \
   15   7

<details><summary>查看代码</summary><pre><code>
class Solution {
public:
    int helper(TreeNode* cur) {
        if (cur == nullptr)return 0;
        int left = helper(cur->left);
        int right = helper(cur->right);
        if (left == -1 || right == -1)return -1;
        return abs(left - right) <= 1 ? max(left, right) + 1 : -1;//若是平衡树则返回树高度，否则返回-1
    }
    bool isBalanced(TreeNode* root) {
        return helper(root) >= 0;
    }
};
</code></pre></details>

## [二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)
给定一棵二叉搜索树，请找出其中第k大的节点。

>输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4

<details><summary>查看代码</summary><pre><code>
//递归遍历：right->root->left即为非递增序列，保存第K个即可
class Solution {
private:
    int count = 0, ans, K;
public:
    void helper(TreeNode* cur) {
        if (cur == nullptr)return ;
        helper(cur->right);
        count++;
        if (count == K)ans = cur->val;
        helper(cur->left);
    }
    int kthLargest(TreeNode* root, int k) {
        K = k;
        helper(root);
        return ans;
    }
};
</code></pre></details>

## [二叉树序列化和反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

<details><summary>查看代码</summary><pre><code>
#include <iostream>
#include <vector>

using namespace std;

class TreeNode {
public:
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int value) {
        val = value;
        left = nullptr;
        right = nullptr;
    }
};

vector<int> xuliehua(TreeNode* root) {
    vector<TreeNode*> s;
    vector<TreeNode*> s1;
    s.push_back(root);
    vector<int> ans;
    while (!s.empty()) {
        for (auto it = s.begin(); it != s.end(); it++) {
            if ((*it) != nullptr) {
                ans.push_back((*it)->val);
                s1.push_back((*it)->left);
                s1.push_back((*it)->right);
            }
            else ans.push_back(INT32_MAX);
        }
        s.clear();
        for (auto _it = s1.begin(); _it != s1.end(); _it++) {
            s.push_back(*_it);
        }
        s1.clear();
    }
    while (*(ans.end()-1)== INT32_MAX)
    {
        ans.pop_back();
    }
    return ans;
}

TreeNode* rexuliehua(const vector<int>& t) {
    TreeNode* root;
    if (t[0] != INT32_MAX)root = new TreeNode(t[0]);
    vector<TreeNode*> s;
    vector<TreeNode*> s1;
    s.push_back(root);
    int i = 1;
    while (!s.empty() && i < t.size()) {
        for (auto it = s.begin(); it != s.end(); it++) {
            if (i >= t.size())break;
            if (t[i] != INT32_MAX) {
                (*it)->left = new TreeNode(t[i]);
                s1.push_back((*it)->left);
            }
            i++;
            if (i < t.size()) {
                if (t[i] != INT32_MAX) {
                    (*it)->right = new TreeNode(t[i]);
                    s1.push_back((*it)->right);
                }
                i++;
            }
        }
        s.clear();
        for (auto _it = s1.begin(); _it != s1.end(); _it++) {
            s.push_back(*_it);
        }
        s1.clear();
    }
    return root;
}

int main() {
    //int a;
    //cin >> a;
    vector<int> a{ 1,2,3,INT32_MAX,4,5};
    TreeNode* root = rexuliehua(a);
    vector<int> ans;
    ans = xuliehua(root);

    cout << "Hello World!" << endl;
}
</code></pre></details>

## [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

<details><summary>查看代码</summary><pre><code>
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (!root)return root;
        TreeNode* temp = root->left;
        root->left = invertTree(root->right);
        root->right = invertTree(temp);
        return root;
    }
};
</code></pre></details>

## [前缀树](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

<details><summary>查看代码</summary><pre><code>
class Trie {
    bool isEnd;
    Trie* next[26];
public:
    /** Initialize your data structure here. */
    Trie() {
        isEnd = false;
        memset(next, 0, sizeof(next));
    }

    /** Inserts a word into the trie. */
    void insert(string word) {
        Trie* node = this;
        for (char c : word) {
            if (node->next[c - 'a'] == NULL) {
                node->next[c - 'a'] = new Trie();
            }
            node = node->next[c - 'a'];   
        }
        node->isEnd = true;
    }

    /** Returns if the word is in the trie. */
    bool search(string word) {
        Trie* node = this;
        for (char c : word) {
            if (node->next[c - 'a'] == NULL) {
                return false;
            }else node = node->next[c - 'a'];
        }
        return node->isEnd;
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        Trie* node = this;
        for (char c : prefix) {
            if (node->next[c - 'a'] == NULL) {
                return false;
            }
            else node = node->next[c - 'a'];
        }
        return true;
    }
};
</code></pre></details>

## [把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。
输入: 原始二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13

<details><summary>查看代码</summary><pre><code>
class Solution {
    int sum=0;
public:
    TreeNode* convertBST(TreeNode* root) {
        if(root!=nullptr){
            convertBST(root->right);
            sum+=root->val;
            root->val=sum;
            convertBST(root->left);
        }
        return root;
    }
};
</code></pre></details>

## [填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。

<details><summary>查看代码</summary><pre><code>
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> q;
        if (root == nullptr)return root;
        q.push(root);
        while (!q.empty()) {
            int Size = q.size();
            for (int i = 0; i < Size; i++) {
                Node* temp = q.front();
                q.pop();
                if (i + 1 == Size)temp->next = nullptr;
                else temp->next = q.front();
                if (temp->left != nullptr)q.push(temp->left);
                if (temp->right != nullptr)q.push(temp->right);
            }
        }
        return root;
    }
};
</code></pre></details>