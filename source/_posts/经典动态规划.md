---
title: 经典动态规划
date: 2020-08-01 16:22:10
mathjax: true
tags:
- 动态规划
---
本文来自labuladong公众号，[详细解析连接](https://gitee.com/wlf621/Interview/tree/master/Algorithm/algorithm.pdf)

## 剪绳子

> 一维dp，每次剪一刀，类似二分化简问题也是常见dp

<details><summary>查看代码</summary><pre><code>
class Solution {//dp[i]表示长度为i的绳子的最大乘积，注意i=1，2，3时特殊（长度大于3时剪一次，i=1,2,3可以不剪）
public:
    int cuttingRope(int n) {
        int max = 0;
        vector<int> dp(n + 1);
        if (n <= 3)return n - 1;
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 3;
        for (int i = 4; i <= n; i++) {
            for (int k = 1; k < i; k++)
                if (max < dp[k] * dp[i - k])max = dp[k] * dp[i - k];
            dp[i] = max;
        }
        return dp[n];
    }
};
</code></pre></details>

## 最长递增子序列

> 一维dp，dp[i]表示以nums[i]结尾的某状态（常见dp方法）

<details><summary>查看代码</summary><pre><code>
//dp[i]表示以nums[i]结尾的最长递增子数列长度,dp[i] = max(dp[j]+1,dp[i]),$j \in [0,i)$;
template<class T>
int lengthOfLIS(vector<T> &nums) {
	int Max = 1;
	vector<int> dp(nums.size(), 1);
	for (int i = 0; i < nums.size(); i++) {
		for (int j = 0; j < i; j++) 
			if (nums[i] > nums[j])
				dp[i] = max(dp[j]+1,dp[i]);
	}
	for (int i = 0; i < nums.size(); i++)Max = max(Max,dp[i]);
	return Max;
}
</code></pre></details>

## [计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)

> 给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。
重复出现的子串要计算它们出现的次数。

<details><summary>查看代码</summary><pre><code>
class Solution {//二维dp，dp[i][j]表示子串[i,j]是否符合条件,超时，通过35/90；
public:
    int countBinarySubstrings(string s) {
        int n = s.size(), sum = 0;
        vector<vector<int>> dp(n,vector<int>(n,0));
        for (int i = 0; i < n - 1; i++) {
            if (s[i + 1] != s[i])dp[i][i + 1] = 1;
        }
        for (int i = n-1; i >= 0; i--) {
            for (int j = i + 2; j < n; j++) {
                if ((j - i + 1) % 2)dp[i][j] = 0;
                else if (s[i] == s[i + 1] && s[j] == s[j - 1] && dp[i + 1][j - 1])dp[i][j] = 1;
                else dp[i][j] = 0;
            }
        }
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
                if (dp[i][j])sum++;
        return sum;
    }
};
</code></pre></details>

<details><summary>查看代码</summary><pre><code>
class Solution {//优化了下一维dp，dp[i]表示子串[0,i]中符合条件的子串数量，通过了85/90，超时
public:
    int countBinarySubstrings(string s) {
        int n = s.size(), sum = 0, count;
        vector<int> dp(n,0);
        for (int i = 1; i < n; i++) {
            if (s[i] != s[i-1])dp[i] = dp[i-1] + 1;
            else {
                count = 2;
                for (int j = i - 2; j >= 0; j--) {
                    if (s[j] == s[i])count++;
                    else break;
                }
                for (int j = i - count; j >= 0; j--) {
                    if (s[j] != s[i] && count > 0)count--;
                    else break;
                }
                if (count == 0)dp[i] = dp[i - 1] + 1;
                else dp[i] = dp[i - 1];
            }
        }
        return dp[n-1];
    }
};
</code></pre></details>

<details><summary>查看代码</summary><pre><code>
class Solution {//官方奇技淫巧篇
public:
    int countBinarySubstrings(string s) {
        int n = s.size(), sum = 0, ptr = 0, count = 0, last = 0;
        vector<int> counts(n,0);
        while (ptr < n) {
            char c = s[ptr];
            int count = 0;
            while (ptr < n && s[ptr] == c) {
                count++;
                ptr++;
            }
            sum += min(last,count);
            last = count;
        }
        return sum;
    }
};
</code></pre></details>

## 剪辑距离
> 字符串t1传换为t2，有三种操作增、删、替换，求最少的操作次数；dp[i][j]表示子串t1.substr(0,i-1)转化为子串t2.substr(0,j-1)的最短剪辑距离，因为下标0用来表示空字符的情况；t1[i]==t2[j]时，无需操作dp[i][j]=dp[i-1][j-1];t1[i]!=t2[j]时,dp[i][j]=min(dp[i-1][j-1]+1,dp[i-1][j]+1,dp[i][j-1]+1);分别表示替换t1[i]位t2[j]，删除t1[i],在t1添加t2[j];

<details><summary>查看代码</summary><pre><code>
int minDistance(string t1,string t2){
	vector<vector<int>> dp(t1.size()+1,vector<int>(t2.size()+1));
	dp[0][0] = 0;
	for (int i = 0; i < t1.size()+1; i++)dp[i][0] = i;
	for (int i = 0; i < t2.size()+1; i++)dp[0][i] = i;
	for (int i = 1; i < t1.size()+1; i++) {
		for (int j = 1; j < t2.size()+1; j++)
			if (t1[i-1] == t2[j-1])dp[i][j] = dp[i-1][j-1];
			else dp[i][j] = min(min(dp[i-1][j-1]+1,dp[i-1][j]+1),dp[i][j-1]+1);
	}
	return dp[t1.size()][t2.size()];
}
</code></pre></details>

## 高楼扔鸡蛋
一栋 1 到 N 共 N 层的楼，然后给你 K 个鸡蛋（ K 至少为 1）。现在确定这栋楼存在楼层 0 <= F <= N ，在这层楼将鸡蛋扔下去，鸡蛋恰好没摔碎（⾼于 F 的楼层都会碎，低于 F 的楼层都不会碎）。现在问你，最坏情况下，你⾄少要扔⼏次鸡蛋，才能确定这个楼层 F 呢？

> dp[k][n]表示k个鸡蛋测n层楼至少要扔鸡蛋的次数；状态转移方程dp[k][n]=max(dp[k-1][i-1]+1,dp[k][n-i]+1),$i \in [1,n]$; 初始状态dp[][0]=0,楼层没了，dp[1][n]=n,只有一个鸡蛋只能从下往上试最差n次。

<details><summary>查看代码</summary><pre><code>
int dropEgg(int k,int n) {
	int res=INT_MAX;
	if (k == 1)return n;
	if (n == 0)return 0;
	for (int i = 1; i <= n; i++) {
		res = min(res,max(dropEgg(k-1,i-1),dropEgg(k,n-i)+1));
	}
	return res;
}
</code></pre></details>

> 二分搜索优化，[详细见文档](https://gitee.com/wlf621/Interview/tree/master/Algorithm/algorithm.pdf)

<details><summary>查看代码</summary><pre><code>
int dropEgg(int k,int n) {
	int l=0,r=n,res=INT_MAX;
	if (k == 1)return n;
	if (n == 0)return 0;
	while (l <= r) {
		int mid = (l + r) / 2;
		broken = dropEgg(k - 1, mid - 1);
		not_broken = dropEgg(k, n - mid);
		if (broken > not_broken) {
			r = mid - 1;
			res = min(res, broken + 1);
		}
		else {
			l = mid + 1;
			res = min(res, not_broken + 1);
		}
	}
	return res;
}
</code></pre></details>

> 另一种状态转移方程，dp[k][m]表示当前有 k 个鸡蛋，可以尝试扔 m 次鸡蛋，最坏情况下最多能确切测试一栋 n 层的楼。状态转移：dp[k][m]=dp[k-1][m-1]+dp[k][m-1]+1,初始状态：dp[0][]=0,dp[][0]=0;

<details><summary>查看代码</summary><pre><code>
int dropEgg(int k,int n) {
	vector<vector<int>> dp(k+1,vector<int>(n+1,0));
	int i = 1, j = 0;
	while (dp[k][j] < n) {
		j++;
		for (i = 1; i <= k; i++)
			dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1] + 1;

	}
	return j;
}
</code></pre></details>

## 最长回文子序列

> 状态转移方程dp[i][j]表示字串[i,j]的最长回文子序列，dp[i][j]=dp[i+1][j-1]+2, if str[i]==str[j]; dp[i][j]=max(dp[i+1][j],dp[i][j-1]), if str[i]!=str[j];初始状态dp[i][i]=1,dp[i][j]=0, if i>j. 注意迭代的方向

<details><summary>查看代码</summary><pre><code>
int longestPalindromeSubseq(string s) {
    int n = s.size();
    vector<vector<int>> dp(n,vector<int>(n,0));
    for (int i = 0; i < n; i++)dp[i][i] = 1;
    for (int i = n-1; i >=0 ; i--) {
        for (int j = i + 1; j < n; j++) {
            if (s[i] == s[j])
                dp[i][j] = dp[i + 1][j - 1] + 2;
            else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
        }
    }
    return dp[0][n - 1];
}

</code></pre></details>

## 最长回文子串

> 最长回文子串,dp[i][j]表示以i和j为首尾的回文子串的长度，dp[i][j]=dp[i+1][j-1]+2, if str[i]==str[j]&&(dp[i+1][j-1]!=1||i+1==j-1); dp[i][j]=0, 其他情况;初始状态dp[i][i]=1,dp[i][j]=0, if i>j;

<details><summary>查看代码</summary><pre><code>
string longestPalindromeSubseq(string s) {
    int n = s.size(), Max = 0, l = 0, r = 0;
    vector<vector<int>> dp(n,vector<int>(n,0));
    for (int i = 0; i < n; i++)dp[i][i] = 1;
    for (int i = n-1; i >=0 ; i--) {
        for (int j = i + 1; j < n; j++) {
            if (s[i] == s[j]&&(dp[i+1][j-1]!=1||i+1==j-1))
                dp[i][j] = dp[i + 1][j - 1] + 2;
            else dp[i][j] = 1;
        }
    }
    for (int i = 0; i < n; i++) 
        for (int j = i; j < n; j++) {
            if (dp[i][j] > Max) {
                Max = dp[i][j];
                l = i; r = j;
            }
        }
    return s.substr(l,r-l+1);
}
</code></pre></details>

## 石头游戏

你和你的朋友面前有一排石头堆，用一个数组piles表示，piles[i]表示第i堆石头有多少个。你们轮流拿石头，一次拿一堆，但是只能拿最左边或者最右边的石头堆。所有⽯头被拿完后，谁拥有的石头多，谁获胜。

>dp[i][j].first、dp[i][j].second表示在石头堆[i，j]中选择先手和后手获得的最高分；
状态转移：dp[i][j].first=max(d[i+1][j].second+piles[i],d[i][j-1].second+piles[j]),dp[i][j].second=d[i+1][j].first or d[i][j-1].first 取决于先手的选择
初始状态：dp[i][i].first=piles[i],dp[i][i].second=0;

<details><summary>查看代码</summary><pre><code>
int stoneGame(vector<int> &piles){
    int n = piles.size();
    vector<vector<pair<int, int>>> dp(n,vector<pair<int,int>>(n,make_pair(0,0)));
    for (int i = 0; i < n; i++)dp[i][i] = make_pair(piles[i],0);
    for (int l = 1; l < n; l++) {
        for (int i = 0; i < n && i + l < n; i++) {
            bool left = true;
            if ((dp[i + 1][i + l].second + piles[i]) > (dp[i][i + l - 1].second + piles[i + l])) {
                dp[i][i + l].first = dp[i + 1][i + l].second + piles[i];
            }
            else {
                dp[i][i + l].first = dp[i][i + l - 1].second + piles[i + l];
                left = false;
            }
            if (left)dp[i][i + l].second = dp[i + 1][i + l].first;
            else dp[i][i + l].second = dp[i][i + l - 1].first;
        }
    }
    return dp[0][n - 1].first - dp[0][n - 1].second;
}
</code></pre></details>

## KMP算法

[LeetCode 28](https://leetcode-cn.com/problems/implement-strstr/)

<details><summary>查看代码</summary><pre><code>
void getNext(string p, vector<int> &next)
{
	next[0] = 0;
	int i = 1, j = 0;

	while (i < p.size()-1)
	{
		if (p[i] == p[j])
		{
			next[++i] = ++j;//若前缀相同，则下一位置匹配失败可回退到相同的前缀处
	
		}
		else if (j == 0)//回退到开始，说明不存在相同的前缀，重新开始匹配
			i++;
		else{
			j = next[j];//当前前缀不相同，继续匹配之前相同的前缀部分
	
		}
	}
}

int search(string txt, string pat, vector<int> &next) {
//匹配方式与求取next相似
	int M = pat.length();
	int N = txt.length();
	// pat 的初始态为 0
	int j = 0;
	for (int i = 0; i < N;) {
		if (txt[i] == pat[j]) 
		{ j++; i++; }
		else if (j == 0)
			i++;
		else 
			j = next[j]; 
		if (j == M)
			return i - M ;
	}
	// 匹配失败
	return -1;
}
</code></pre></details>

## [最短回文串](https://leetcode-cn.com/problems/shortest-palindrome/)

给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。

>输入: "aacecaaa"
输出: "aaacecaaa"

<details><summary>查看代码</summary><pre><code>
//找到以s[0]开头的最长回文子串s'然后将s-s'反转后放在开头即为最短回文串，问题关键在于求s[0]开头的最长回文子串
//动态规划DP可以在O（n^2）的时间内找到s[0]开头的回文子串，超时。
class Solution {
public:
    string shortestPalindrome(string s) {
        int n = s.size(), Max = 0;
        string t = "";
        vector<vector<bool>> dp(n, vector<bool>(n, false));
        for (int i = 0; i < n; i++)dp[i][i] = true;
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                if (s[i] == s[j] && (dp[i + 1][j - 1] != false || (i + 1 > j - 1)))
                    dp[i][j] = true;
                else dp[i][j] = false;
            }
        }
        for (int i = 0; i < n; i++) {
            if (dp[0][i] != false && i > Max)Max = i;
        }
        for (int i = s.size() - 1; i > Max; i--) {
            t = t + s[i];
        }
        return t + s;
    }
};

//KMP 算法
/*
将串s反转为s'然后用s匹配s'，遍历到s'的结尾时，匹配到s的第i字符，前i个字符即为s[0]开头的最长回文子串
*/
class Solution {
public:
    string shortestPalindrome(string s) {
        int n = s.size(), Max = 0;

        //next数组
        vector<int> next(n,0);
        int i = 1, j = 0;
        while (i < n - 1) {
            if (s[i] == s[j])
                next[++i] = ++j;
            else if (j == 0)i++;
            else j = next[j];
        }
        
        string s1 = s;
        reverse(s1.begin(), s1.end());
        i = 0; j = 0;
        for (; i < n;) {
            if (s1[i] == s[j])
            {
                Max = j;
                j++; i++;
            }
            else if (j == 0)
                i++;
            else
                j = next[j];
        }

        string t = "";
        for (int i = s.size() - 1; i > Max; i--) {
            t = t + s[i];
        }
        return t + s;
    }
};

</code></pre></details>

## 浪潮编程石头

<details><summary>查看代码</summary><pre><code>
int main() {
    int n, ans = 0,num;
    cin >> n;
    int* stones = new int[n];
    int* dp = new int[n];
    for (int i = 0; i < n; i++) {
        cin >> stones[i];
    }
    for (int i = 0; i < n; i++) {
        dp[i] = stones[i];
        for (int j = i + 1; j < n; j++)
        {
            dp[j] = stones[j];
            if (dp[i] + 1 == dp[j])
            {
                num = num + 1;
                dp[i] = dp[j];
            }
        }
        if (num > ans)
        {
            ans = num;
        }
        num = 1;
    }
    cout << n - ans << endl;
    return 0;
}
</code></pre></details>

## [不同路径](https://leetcode-cn.com/problems/unique-paths)
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？

<details><summary>查看代码</summary><pre><code>
//dp[i][j]=dp[i][j-1]+dp[i-1][j]
</code></pre></details>

## 股票的最大利润
假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。

<details><summary>查看代码</summary><pre><code>
//dp[i],前i天的最大利润，状态转移dp[i]=max(dp[i-1],price[i]-min(price[0],price[i-1])),第i天卖和第i天不卖的较大值。
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0)return 0;
        vector<int> dp(prices.size(), 0);
        int Min = prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[i] = max(dp[i - 1], prices[i] - Min);
            Min = min(Min, prices[i]);
        }
        return dp[prices.size() - 1];
    }
};//另一种思路，存储相隔两天的收益（前一天买后一天卖），最大利润即最大连续和
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size()==0)return 0;
        int max=0,sum=0;
        for(int i=0;i<prices.size()-1;i++)prices[i]=prices[i+1]-prices[i];
        for(int i=0;i<prices.size()-1;i++){
            sum+=prices[i];
            if(sum<0)sum=0;
            if(sum>max)max=sum;
        }
        return max;
    }
};
</code></pre></details>

## [最小移动次数使数组元素相等](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/)
深信服2020笔试
给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 n - 1 个元素增加 1。

>输入:
[1,2,3]
输出:
3
解释:
只需要3次移动（注意每次移动会增加两个元素的值）：
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]

<details><summary>查看代码</summary><pre><code>
//先排序然后dp，dp[i]表示排序后[0,i]相等所需的移动步数，dp[i]=dp[i-1]+(nums[i]+dp[i-1])(移动后的当前nuns[i]值)-(nums[i-1]+dp[i-2])(移动后的当前nuns[i-1]值)
class Solution {
public:
    int minMoves(vector<int>& nums) {
        vector<int> dp(nums.size(),0);
	    sort(nums.begin(), nums.end());
	
	    for (int i = 1; i < nums.size(); i++) {
		    dp[i] = 2 * dp[i - 1] + nums[i] - nums[i - 1] - (i - 2 >= 0 ? dp[i - 2] : 0);
	    }
	    return dp[nums.size() - 1];
    }
};
</code></pre></details>

## [Dijkstra算法]

<details><summary>查看代码</summary><pre><code>
void dijkstra(vector<vector<double>> weight,int start) {
    int n = weight.size(); // 顶点个数
    int *shortPath = new int[n]; // 保存start到其他各点的最短路径
    string *path = new string[n]; // 保存start到其他各点最短路径的字符串表示
    for (int i = 0; i < n; i++)
        path[i] = to_string(start) + "-->" + to_string(i);
    int* visited = new int[n]; // 标记当前该顶点的最短路径是否已经求出,1表示已求出
    memset(visited, 0, sizeof(int) * n);
    // 初始化，第一个顶点已经求出
    shortPath[start] = 0;
    visited[start] = 1;

    for (int count = 1; count < n; count++) { // 要加入n-1个顶点
        int k = -1; // 选出一个距离初始顶点start最近的未标记顶点
        int dmin = INT_MAX;
        for (int i = 0; i < n; i++) {
            if (visited[i] == 0 && weight[start][i] < dmin) {
                dmin = weight[start][i];
                k = i;
            }
        }

        // 将新选出的顶点标记为已求出最短路径，且到start的最短路径就是dmin
        shortPath[k] = dmin;
        visited[k] = 1;

        // 以k为中间点，修正从start到未访问各点的距离
        for (int i = 0; i < n; i++) {
            //如果 '起始点到当前点距离' + '当前点到某点距离' < '起始点到某点距离', 则更新
            if (visited[i] == 0 && weight[start][k] + weight[k][i] < weight[start][i]) {
                weight[start][i] = weight[start][k] + weight[k][i];
                path[i] = path[k] + "-->" + to_string(i);
            }
        }
    }
}
</code></pre></details>
